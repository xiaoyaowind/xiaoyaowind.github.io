---
layout: post 
title: 高性能编程系列-内存屏障和cpu缓存 
category: java 
tags: [java]
keywords: 内存屏障和cpu缓存,内存屏障,cpu缓存
---

# 1.CPU 性能优化手段-缓存

为了提高程序运行的性能,现代CPU在很多方面对程序进行了优化。 例如:CPU高速缓存。尽可能地避免处理器访问主内存的时间开销,处理器大多会利用缓存 (cache) 以提高性能。
![简洁版](http://image.xiaoyaowind.com/image/202203212239973.png)
![详细版](http://image.xiaoyaowind.com/image/202203212245014.png)

# 2.多级缓存

L1 Cache （一级缓存）是CPU第一层高速缓存，分为数据缓存和指令缓存。一般服务器CPU的L1缓存的容量通常在32—4096KB。

L2 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一高速存储器，即二级缓存。

L3 现在的都是内置的。而它的实际作用即是，L3 缓存的应用可以进一步降低内存延迟，同时 提升大数据量计算时处理器的性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为 及较短消息和处理器队列长度。一般是多核共享一个 L3 缓存！

CPU在读取数据时，先在L1中寻找，再从L2寻找，再从L3寻找，然后是内存，再后是外存储器。

# 3.缓存同步协议

多CPU读取同样的数据进行缓存，进行不同运算之后，最终写入主内存以哪个CPU为准? 在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。 

MESI协议，它规定每条缓存有个状态位，同时定义了下面四个状态：

- 修改态 (Modred)----此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有;
- 专有态 (Exclusive)----此cache行内容同于主存，但不出现于其它cache中；
- 共享态 (Shared)----此cache行内容同于主存，但也出现于其它cache中；
- 无效态 (Invalid)----此cache行内容无效(空行)。

多处理器时,单个CPU对缓存中数据进行了改动,需要通知给其他CPU。也就是意味着,CPU处理要控制自己的读写操作,还要监听其他CPU发出的通知,从而保证*最终一致*。

# 4.CPU 性能优化手段-运行时指令重排

![指令重排](http://image.xiaoyaowind.com/image/202203212303853.png)

指令重排的场景:当 CPU 写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能,
可能将后面的*读缓存命令*优先执行。

但并非随便重排，需要遵守 *as-if-serial* 语义

as-if-serial 语义的意思指:不管怎么重排序(编译器和处理器为了提高并行度),(单线程)
程序的执行结果不能被改变。编译器,runtime和处理器都必须遵守 as-if-serial 语义。
也就是说:编译器和处理器 *不会对存在数据依赖关系的操作做重排序*。

两个问题

&nbsp;&nbsp;&nbsp;&nbsp;1 、 CPU高速缓存下有一个问题：
缓存中的数据与主内存的数据并不是实时同步的,各CPU(或CPU核心)间缓存的数据也不是实时同步。在同一个时间点,各CPU所看到同一内存地址的数据的值可能是不一致的。 

&nbsp;&nbsp;&nbsp;&nbsp;2 、 CPU 执行指令重排序优化下有一个问题：
虽然遵守了*as-if-serial*语义,但仅在单CPU自己执行的情况下能保证结果正确。多核多线程中,指令逻辑无法分辨因果关联,可能出现乱序执行,导致程序运行结果错误。
